# MIT LICENSE Copyright (c) 2018 David Longnecker

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


import src.parser as parser
import src.ast.traverse.display as tv_display
import src.ast.transform.mainpass as tf_mainpass
import src.ast.transform.flattengroups as tf_flattengroups
import src.ast.transform.backpatching as tf_jumpresolution
import src.ast.traverse.segments as tv_segments
import src.error as err
import src.disassemble as dsm
import sys
import copy


_usage_str = 'Usage: [file | <flag:arg>] [...]'
_n_skip     = 0
_n_err      = 1
_n_die      = 2
_n_ok       = 3


def _do_build_segments(source):
    env = {}
    p = parser.Parser()
    out = p.m_module(source)
    ast = out.mod
    ast = tf_mainpass.visit(ast, env)
    ast = tf_flattengroups.visit(ast, env)
    ast = tf_jumpresolution.visit(ast, env)
    result = tv_segments.visit(ast, env)
    return result, ast


def _do_assemble_file(fp, env):
    pi = env['pathinfo']
    if not fp in pi:
        err.fatal('Internal error, unable to fetch path data for file', fp)
    fdata = pi[fp]
    source = None
    try:
        with open(fp, 'r') as f:
            source = f.read()
    except FileNotFoundError:
        err.fatal('Unable to find file:', target)
    except IOError as e:
        err.fatal('Unable to open file:', target)
    segments, ast = _do_build_segments(source)
    dest = env['dest']
    filename = fdata['name']
    if dest:
        # This is not portable (for now)...
        out = dest + '/' + filename + '.csm'
    else:
        out = filename + '.csm'
    try:
        with open(out, 'w+b') as f:
            for s in segments:
                f.write(s)
    except IOError as e:
        err.fatal('Unable to write file:', out)
    if env['dsegments']:
        print('Displaying generated byte segments for file:', fp)
        for s in segments:
            print('  ', str(s)[1:])
    elif env['dast']:
        print('Displaying generated AST for file:', fp)
        tv_display.visit(ast)


def _do_disassemble_file(fp, env):
    pathinfo = env['pathinfo']
    if not fp in pathinfo:
        err.fatal('Internal error, unable to fetch path data for file', fp)
    fdata = pathinfo[fp]
    source = None
    try:
        with open(fp, 'r+b') as f:
            source = f.read()
    except FileNotFoundError:
        err.fatal('Unable to find file:', target)
    except IOError as e:
        err.fatal('Unable to open file:', target)
    output = dsm.disassemble(source)
    print('Disassembly for file:', fp)
    print(output)
    if not env['logdsm']:
        return
    # Do this 
    dest = env['dest']
    filename = fdata['name']
    if dest:
        # This is not portable (for now)...
        out = dest + '/' + filename + '.dis'
    try:
        with open(out, 'w') as f:
            f.write(output)
    except IOError as e:
        err.fatal('Unable to write file:', out)


def _loop_through_files(action, env):
    files = env['files']
    if len(files) == 0:
        err.fatal('No input files provided!')
    for fp in files:
        action(fp, env)


#-----------------------------------------------------------------------------
# ENTRYPOINTS


def _entrypoint_soft_quit(env):
    pass


def _entrypoint_default(env):
    _loop_through_files(_do_assemble_file, env)


def _entrypoint_disassemble(env):
    _loop_through_files(_do_disassemble_file, env)


#-----------------------------------------------------------------------------
# FLAG HANDLERS


def _flag_output_relative(arg, env):
    env['dest'] = '.' + '/' + arg


def _flag_output_explicit(arg, env):
    env['dest'] = arg


def _flag_dsegments(arg, env):
    env['dsegments'] = True


def _flag_dsm(arg, env):
    env['entrypoint'] = _entrypoint_disassemble


def _flag_logdsm(arg, env):
    env['logdsm'] = True


def _flag_info(arg, env):
    print('INFO FLAG')


def _flag_dast(arg, env):
    env['dast'] = True
    

def _flag_help(arg, env):
    print(_usage_str)
    fc = len(_flag_table)
    print('The following', fc, 'flags exist:')
    for flag in _flag_table:
        message = 'No description provided'
        if flag in _flag_descriptions:
            message = _flag_descriptions[flag]
        padding = _max_flag_length - len(flag)
        padbreak = ' '
        print(('-' + flag), (padding * ' '), padbreak, message)
    print()


# flag : (handler, no_files_reaction, takes_arg, argtype_string)
# no_files_reaction:
#   _n_skip     = Skip parsing this flag
#   _n_err      = Log an error
#   _n_die      = Log a fatal error
#   _n_ok       = Parse anyway
_flag_table = {
    'or'        : (_flag_output_relative,   _n_skip,    True,   'str'   ),
    'ox'        : (_flag_output_explicit,   _n_skip,    True,   'str'   ),
    'dsegments' : (_flag_dsegments,         _n_err,     False,  None    ),
    'dast'      : (_flag_dast,              _n_err,     False,  None    ),
    'dsm'       : (_flag_dsm,               _n_err,     False,  None    ),
    'logdsm'    : (_flag_logdsm,            _n_err,     False,  None    ),
    'info'      : (_flag_info,              _n_ok,      True,   'str'   ),
    'help'      : (_flag_help,              _n_ok,      False,  None    ),
}


_flag_descriptions = {
    'or'        : 'Modify output directory, relative path',
    'ox'        : 'Modify output directory, explicit path',
    'dsm'       : 'Attempt to disassemble the given files as CSM bytecode',
    'logdsm'    : 'Write disassembly logs to output directory',
    'info'      : 'Query detailed info about a given flag',
    'help'      : 'Display this message'
}


def _get_max_flag_length():
    result = 0
    for key in _flag_table:
        length = len(key)
        if length > result:
            result = length
    return result


_max_flag_length = _get_max_flag_length()


def _parse_arg(arg, argtype):
    if not argtype:
        return
    result = None
    if argtype == 'str':
        return arg
    if fw.is_valid_range(argtype):
        return fw.restrict(arg, argtype)
    err.fatal('Internal error, unrecognized argtype', argtype)


def _split_flag_string(rawflag):
    flag = None
    arg = None
    split = rawflag.rsplit(':', 1)
    flag = split[0]
    if len(split) > 1:
        arg = split[1]
    return (flag, arg)


def _parse_flag(rawflag, env):
    flag, arg = _split_flag_string(rawflag)
    if not flag in _flag_table:
        err.fatal('Unrecognized flag:', flag)
    if flag in env['switched']:
        return
    handler, no_files_reaction, takes_arg, argtype = _flag_table[flag]
    nfr = no_files_reaction
    nofiles = env['nofiles']
    if nfr < _n_skip or nfr > _n_ok:
        err.fatal('Internal error, bad no_files_reaction value:', nfr)
    elif nfr == _n_skip and nofiles:
        return
    # We will need to program a more robust error system soon.
    elif nfr == _n_err and nofiles:
        err.fatal('Flag', flag, 'requires input files!')
    elif nfr == _n_die and nofiles:
        err.fatal('Flag', flag, 'requires input files!')
    elif nfr == _n_ok:
        env['gracefail'] = True
    if arg and not takes_arg:
        err.fatal('Flag', flag, 'does not accept arg, found:', arg)
    if takes_arg and not arg:
        err.fatal('Flag', flag, 'expects arg of type:', argtype)
    parsed_arg = _parse_arg(arg, argtype)
    env['switched'][flag] = parsed_arg
    handler(parsed_arg, env)


_default_environment = {
    'pathinfo'      : {},
    'dest'          : None,
    'entrypoint'    : _entrypoint_default,
    'switched'      : {},
    'files'         : None,
    'flags'         : None,
    'argv'          : None,
    'nofiles'       : True,
    'gracefail'     : False,
    'logdsm'        : False,
    'dsegments'     : False,
    'dast'	        : False
}


def _env_attach_file_pathinfo(target, env):
    prefix = None
    name = None
    split = target.rsplit('/', 1)
    if len(split) > 1:
        prefix = split[0]
        name = split[1]
    else:
        name = split[0]
    env['pathinfo'][target] = {
        'full'      : target,
        'prefix'    : prefix,
        'name'      : name
    }


def env_init(files, flags, argv):
    result = _default_environment
    if not files and not flags:
        print(_usage_str)
        result['entrypoint'] = _entrypoint_soft_quit
        return result
    result = copy.deepcopy(_default_environment)
    result['files'] = files
    result['flags'] = flags
    result['argv'] = argv
    result['nofiles'] = len(files) == 0
    for fp in files:
        _env_attach_file_pathinfo(fp, result)
    for string in flags:
        if len(string) == 1 or string[0] != '-':
            err.fatal('Internal error, unable to parse flag', string)
        rawflag = string[1:]
        _parse_flag(rawflag, result)
    if (result['nofiles']) and result['gracefail']:
        result['entrypoint'] = _entrypoint_soft_quit
    return result
